# c++面向对象基本原则  
## 单一职责原则  
* 一个类，只有一个引起它变化的原因。应该只有一个原则。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责耦合在一起，这会导致脆弱的设计。  
当一个职责发生变化时，可能会影响其他职责。另外，多个职责耦合在一起，会影响复用性。  
* 单一职责的优点：  
a.可以降低类的复杂度，一个类值负责一项职责，其逻辑肯定要比负责多项职责简单的多；
b.提高类的可读性，提高系统的可维护性；
c.变更引起的风险降低，变更是必然的，如果单一职责遵守的好，当修改一个功能时，可显著降低对其他功能的影响。 
* 变化的方向隐含着类的责任； 

## 依赖倒置原则  
* a.高层模块不应该依赖于底层模块，二者都应该依赖于抽象。  
b.抽象不应该依赖于细节，细节应该依赖于抽象。  
* 最重要的还是抽象层，如果客户需要的功能，在抽象层都能够实现（一定实在抽象层实现），并且抽象层暴露在外部的数据是最简化，那么剩下的逻辑性实现就都在继承类中操作。  
* 简单来说就是模块间调用都是通过抽象类接口，实现类之间不存在直接关系，他们之间都是通过抽象类或接口实现的。  
* 接口或抽象类不依赖于实现类；而实现类依赖于抽象类或接口。  

## 开放封闭原则  
* 对扩展开放，对更改封闭  
* 类模块应该是可扩展的，但是不可修改的。

## Liskov替换原则(LSP)
* 子类必须能够替换它们的父类(IS-A)  
* 继承表达类型抽象

## 接口隔离原则(ISP)
* 不应该强迫客户程序依赖它们不用的方法；
* 接口应该小而完备

## 优先使用对象组合，而不是类继承
* 类继承通常为“白箱复用”，对象组合通常为“黑箱复用“；
* 继承在某种程度上破坏了封装性，子类父类耦合度高；
* 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

## 封装变化点
* 使用封装来创建对象之间的分界层，让设计者可以在分界的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。


## 针对接口编程，而不是实现编程
* 不将变量类型声明为某个特定的具体类，而是声明为某个接口；
* 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口；
* 减少系统中各部分的依赖关系，从而实现”松耦合，高内聚“的类型设计方案。
* 松耦合：尽可能降低模块间的耦合；
* 高内聚：尽可能提高系统模块内部的内聚；

## 面向接口设计
* 产业强盛的标志
* 接口标准化

## 将设计原则提升为设计经验
### 设计习语Design Idioms
- 描述与特定编程语言相关的底层模式、技巧和惯用法；  
### 设计模式 Design Patterns
- 主要描述的是类与相互通信的对象之间组织关系，包括它们的角色、职责、协作方式等方面。-
### 架构模式 Architectural Patterns
- 描述系统中与基本结构组织关系密切的高层模式，包括子系统划分、职责、以及如何组织它们之间的关系规则。

# 常用的设计模式：
## 创建型模式
### Factory工厂模式  
- 提高内聚、松耦合  
- 应用场景：父类中并不知道具体要实例化哪一个具体的子类的问题。
- 限制：仅仅局限于一个类别的类（所有子类有一个共同的父类），如果我们要为不同类别的类提供一个对象创建的接口，那就要用AbstactFactory模式了。
### AbstactFactory抽象工厂模式  

## 结构型模式
### Bridge桥接模式  

## 行为模式
### Template模板模式  

### Strategy策略模式  

### Observer观察者模式  
- 软件开发过程中必须要掌握和使用的模式之一  
- 应用场景：建立一个"一(Subject)对多(Observer)"的依赖关系，并且做到当"一(Subject)"变化的时候，依赖这个"一"的"多(Observer)"也能同步改变。  
一个简单的例子：对同一组数据进行统计分析的时候，希望能够提供多种形式的表示（表格、柱状图、百分比统计等），这些表示都依赖于同一组数据。因此，我们需要当数据改变的时候，所有统计的显示都能够同时改变。  
- Observer模式也称为发布——订阅，目标就是通知的发布者，观察者则是通知的订阅者(接受通知)。
































































