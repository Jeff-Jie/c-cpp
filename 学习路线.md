[TOC]
<div style='display: none'> [TOC] 为目录</div>
- <注>：在恰当的场合使用恰当的特性

# c++服务器开发
## c++语言
### c++初级
#### 命名空间
#### 面向对象编程思想
#### 类的封装
#### 构造与析构
#### 静态成员
#### This指针
#### 友元函数与友元类
#### 运算符重载、函数重载
#### 继承与派生
#### 虚函数与多态
#### 函数模板与类模板
#### 输入输出流
#### 异常处理
### c++中/高级——c\+\+标准库
#### 标准c++ I/O类（了解）
- ios：抽象基类
- istream：通用输入流和其他输入流的基类
- ostream：通用输出流和其他输出流的基类
- iostream：通用输入输出流和其他输入输出流的基类
- ifstream：输入文件流类
- ofstream：输出文件流类
- fstream：输入输出文件流类
- istrstream：输入字符串流类
- ostrstream：输出字符串流类
- strstream：输入输出字符串流类
#### 字符串string类
- 数据结构
#### 数值类?
#### STL容器类（基本数据结构和原理）
- vector: 每个元素在内存上是连续的，支持高效遍历、尾端插入和删除；
```
（1）特点：
	- 动态数组，在堆中分配内存，即使大小减小，内存也不会释放；如果新值 > 当前大小，会再分配内存；
	- 内存的动态增长，首地址不变；
	- 地址连续的顺序序列；
	- 能够感知内存分配器的（Allocator-aware）：
		vector使用一个内存分配器对象来动态的处理存储需求；
```
- list: 元素地址不连续，具有双链表结构，支持高效的随机插入/删除；
```
（1）特点：
	- 线性双向链表结构，有若干节点，每个节点包括一个信息块、一个前驱指针和一个后继指针；
	- 不支持[]操作符和at()函数；
	- 相对于vector，占用更多内存；（因为每个节点至少包含2个指针）
```
- map: 关联容器，提供一对一的数据处理能力；
```
（1）特点：
	- map内部自建一颗红黑树（一种非严格意义上的平衡二叉树）
		这棵树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的；
    - 根据key值快速查找记录，查找的复杂度基本是log(n)，例如：
    	如果有1000个记录，最多查找10次；
        如果有1000000个记录，最多查找20次；
```
- 队列:
```
（1）queue： 是一个容器适配器类型
	- 特点：
		a.队列是一个容器适配器类型，被设计成用来运行FIFO（先进先出）场景；
	- 队列在多线程中的应用：
		a.生产——消费模型，实现解耦；
（2）dequeue: 每个元素在内存上是连续的，支持高效遍历、首/尾端插入和删除；
	- 双端队列的数据被表示为一个分段数组，容器中的元素分段存放在一个大小固定的数组中；
	- 容器需要维护一个存放这些数组首地址的索引数组；
	- 特点：
		a.首地址的索引数组地址连续，双端队列本质上每一段的地址不连续；
（3）priority_queue：优先队列
	- 具有队列的所有特性，包括基本操作，在这基础上，增加了一个内部的排序，本质是一个堆实现的（默认是大顶堆）
	- 特点：
		a.队列中的最大元素总是位于首部（出队时，是将当前队列中最大的元素出队）
        b.元素的比较规则默认按照元素值由大到小排序（可以重载'<'来重新定义比较规则）
    	c.在默认的优先队列中，优先级高的先出队（在默认的int型中，先出队的为最大的数）
```
#### STL算法库algorithm
#### STL函数对象（仿函数）
- 概念：
```
（1）函数对象：
	- 首先，是一个对象：即某个类的示例；
	- 其次，函数对象的行为和函数一致：即可以像调用函数一样来使用函数对象（参数传递、返回值等），这种方式是通过重载类的'()'操作符实现的；
（2）重载'()'操作符的类，它的对象叫做“函数对象”，即它是类似于函数的对象（可以像函数一样调用），称为“仿函数”；
	<注>：函数对象（仿函数）是一个类，不是一个函数；
（3）术语：
	- 一元仿函数：重载'()'操作符有一个参数；
	- 二元仿函数：重载'()'操作符有两个参数；
	- 一元谓词： 返回值是bool类型的函数对象或普通函数，有一个参数；
	- ...
（4）STL内建的函数对象 #include <functional>
	- 算数类函数对象：
	- 关系运算类：
	- 逻辑运算类：
	<注>：用这些类的对象当做函数使用时，用法与函数完全相同；
```
- 函数对象的作用和应用场景：
#### STL迭代器
- 迭代器（iterator）：是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器；
- 抽象思想的经典应用：迭代器作为容器(vector、list等)与STL算法的“粘黏剂”，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中；
- 实现：
```
（1）内部构成 ：
	- 提供一个遍历容器内部所有元素的接口，因此内部必须保存一个与容器相关联的指针；
	- 重载常用的运算符来方便遍历（其中最重要的是'*'、'->'和'++'）；
	- 
```
#### STL分配器（后续重点了解）
#### 本地化库
- [本地化库](https://zh.cppreference.com/w/cpp/locale)
#### 异常处理类
- [c++异常处理底层机制](https://blog.csdn.net/pzp201833/article/details/80996133)
- [c++异常处理基本思想](https://blog.csdn.net/zyq522376829/article/details/46775931)
#### 杂项支持库（非重点）
### c++精通（c\+\+11/14/17新特性）
#### nullptr
- c++空指针
- c的NULL与c++的nullptr：
```
（1）区别：
	- NULL在c++中，被明确定义为整数0；
	- NULL在c中，被定义成 ((void*)0)；（即：NULL实际上是一个void*指针）；
（2）特点：
	- nullptr用于标识空指针，是std::nullptr_t类型的(constexpr)变量；
	- nullptr可以转换成任何指针类型和bool类型；（主要为了兼容普通指针可以作为条件判断语句的写法）
	- nullptr不能被转换为整数；
```
#### constexpr（常量表达式）
- constexpr修饰的是编译时期的常量；
- const与constexpr的区别：
```
（1）const为运行时常量，constexpr为编译时常量（与#define作用相同）；
	const和constexpr修饰的都是read-only的值，但：
    	- constexpr在程序执行前已经得到了具体的值；
    	- const在程序执行过程中，得到的具体值；
```
- constexpr常量表达式的要求：
```
	并非所有的函数都有资格成为常量表达式函数，具体要求如下：
（1）函数体只有单一的return返回语句；
（2）函数必须有返回值（即，不能为void函数）；
（3）在使用前必须已有定义；
（4）return返回语句表达式中不能使用非常量表达式的函数、全局数据，并且必须是一个常量表达式；
```
- constexpr的优势：
```
（1）是一种很强的约束，更好的保证程序的正确语义不被破坏；
（2）编译器可以在编译时对constexpr的代码进行非常大的优化，比如：将用到constexpr表达式都直接替换成最终结果；
（3）相比宏定义来说，没有额外开销，但更安全可靠；
```
#### auto
- c++98 auto:（极少使用）
- c++11 auto:
```
（1）特点：
	- auto可以在声明变量的时候，根据变量初始值类型，自动推断匹配的类型；
		类似的关键字还有decltype；
        可以使用typeid(i).name()获得变量的类型；
    - auto的自动类型推断发生在编译时期，所以使用auto并不会造成程序运行时的效率问题；
（2）用途：
	- 用于代替冗长复杂、变量使用范围专一的变量声明；
	- 在定义模板函数时，用于声明以来模板参数的变量类型；
	- 用于模板函数依赖于模板参数的返回值
		<注>：第二点和第三点是因为模板参数的类型是可变的，无法在函数内部形成统一的变量类型；
（3）注意事项：
	- auto变量必须在定义时初始化，这点类似与const；
	- 定义在一个auto序列的变量，必须时钟推导成同一类型；
	- 如果初始化表达式是引用，则去除引用语义；
	- 如果初始化表达式为const或volatile（或者两者兼有），则去除const/volatile语义；
	- 如果auto关键字带上&号，则不去除const语义；
	- 初始化表达式为数组时，auto关键字推导类型为指针；
	- 若表达式为数组且auto带上&号，则推导类型为数组类型；
	- 函数参数或模板参数不能被声明为auto；（c++11错误，c++14可以使用auto参数）
```
#### decltype
- 与auto关键字一样，用于进行编译时类型推导，它与auto的区别是：
```
	- decltype的类型推导不像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型；
	- decltype不会对表达式进行求值；
```
- decltype使用方法：
```
	- 推导出表达式类型；
		int i = 4;
        decltype(i) a;	// 推导结果为int，声明a变量的类型为int；
	- 与using/typedef合用，用于定义类型；
		using size_t = decltype(sizeof(0));	// sizeof(a)的返回值为size类型
	- 重用匿名类型；
		struct {
        	int d;
            double b;
        }anon_s;
        decltype(anon_s) as;	// 定义了一个上面匿名的结构体；
	- 泛型编程中结合auto，用于追踪函数的返回值类型；（decltype的最大用途）
		template<typename _Tx, typename _Ty>
        auto multiply(_Tx x, _Ty y)->decltype(_Tx*_Ty) {
        	return x*y;
        }
```
- decltype推导的四条规则：
```
（1）如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型；
	此外，如果e是一个被重载的函数，则会导致编译错误；
（2）否则，假设e的类型是T，如果e是一个将亡值，那么decltype(e)为T&&；
（3）否则，假设e的类型是T，如果e是一个左值，那么decltype(e)为T&；
（4）否则，假设e的类型是T，则decltype(e)为T；
```
#### 区间迭代（范围for循环）
- string、array和所有的STL容器，都可以被新的区间迭代方式迭代；
- 如果想让自己的数据结构使用区间迭代语法，则需要：
```
	- 这个数据结构必须要有begin()和end()方法，成员方法和独立函数都可以，这两个方法分别返回开始和结束的迭代器；
	- 迭代器支持'*'操作符、'!='操作符、'++'方法（前缀形式、成员函数和独立函数都可）；
  实现这5个函数，就可以有一个支持区间迭代的数据结构。
  begin()和end()可以是非成员函数，甚至可以适配现有的数据结构，而不用实现STL风格的迭代器。
  因此，需要做的就是创建自己的支持*、前++和!=的嗲带起，并定义好自己的being()和end()；
```
- 区间迭代可以与STL中的for_each有着同样的性能；
#### 初始化列表
- [列表初始化](https://blog.csdn.net/hailong0715/article/details/54018002)
#### 模板增强
- 模板函数的默认模板参数；
- 外部模板：是c++11中一个关于模板性能上的改进；

#### 面向对象增强
#### Lambda表达式
- lambda表达式本质上就是重载了()运算符的类，称为“functor”，即行为像函数的类。因此，lambda表达式对象其实就是一个匿名的functor；
- 说明：
```
（1）构成：
	- 一个标准的lambda表达式包括：
		捕获列表：捕获外部变量列表；
        	值捕获、引用捕获和外部捕获；
        参数列表：形参列表；
        mutable指示符：用来说明是否可以修改捕获变量；
        exception：异常设定；
        尾置返回类型(->返回类型)：返回类型；
        函数体：函数体
        [capture list](params list) mutable exception->return type {function body};
    - 根据反汇编分析，lambda表达式中的代码是在一个单独的函数中执行的，这个函数在调用时创建了自己的栈帧，而捕获的变量在其他的栈帧中（虽然通过ebp可以进行栈帧回溯，但显然是一种不合理的做法）。
（2）注意：
	- 如果lambda表达式中忽略括号和形参列表，则相当于指定的函数没有入参；
	- lambda表达式中不能指定参数的默认值；
	- 如果忽略返回值类型，则由编译器做自动类型推断；
```
- 捕获列表：由于lambda表达式在某函数内定义的，因此会希望其能使用函数内部的局部变量，这时可以使用“捕获列表”
```
	- 值捕获：
		值捕获和参数传递中的值传递类似，被捕获的变量的值，在lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响lambda表达式中的值；
       	<注>：不能在lambda表达式中修改捕获变量的值；
    - 引用捕获：
    	使用引用捕获一个外部变量，需要在捕获列表变量前面加上一个引用说明符&；
    - 外部捕获（隐式捕获）：
    	我们可以让编译器根据函数体中的代码来推断需要捕获哪些变量；
        隐式捕获有两种方式：
        	[=]：表示以值捕获的方式捕获外部变量；
            [&]：表示以引用捕获的方式捕获外部变量；
```
#### 函数对象包装器
- 说明：
```
	c++11 std::function是一种通用、多态的函数封装，它的示例可以对任何可以调用的目标实体进行存储、复制和调用；
    它也是对c++中现有的可调用实体的一种类型安全的包装（相对来说，函数指针的调用不是类型安全的）；
    std::function是函数的容器，可以更加方便的将函数、函数指针作为对象进行处理；
```
#### 右值引用(std::move)
- [右值引用](https://www.cnblogs.com/likaiming/p/9045642.html)
- 左值和右值的区分标准：能否获取地址：
```
	- 左值：可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值；
		但是修饰符const的出现，使得可以声明如下标识符，它可以获取地址，但是没办法对其赋值：
        	const int& i = 10;
	- 右值表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等；无法获取地址，但不代表其不可改变，当定义了右值的右值引用时，就可以改变右值；
```
- c++11增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置：
```
	即： 右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置：（临时变量会引用关联到右值时，右值被存储到特定位置）
    	int && iii = 10;
```
- 右值引用和移动语义：
```
（1）说明：
	- 在旧的c++中，出现了很多不必要的拷贝，因为在某些情况下，对象拷贝完成后就销毁了；
	- c++11新标准，引入了移动操作，减少了很多复制操作，而右值引用正式为了支持移动操作为引入的新的引用类型；
（2）std::move()函数：
	- 根据右值引用的语法规则，不能将右值引用绑定到一个左值上，c++11引入右值引用，并且提供了std::move()函数，用来获得绑定到左值上的右值引用（即：为右值引用绑定到左值提供了可能）
	- 该函数需要：#include <utility>
		int &&iii = std::move(ii);
```
#### 新增容器
- array:
- forward_list:
- unordered_map:
- unordered_set:
- unordered_multimap:
- unordered_multiset:
- tuple(元组):
#### 智能指针
- 理解智能指针：
```
	作用：方便管理堆内存；
    三个层次：
    	- 较浅层面：
    		智能指针利用一种叫“RAII”（资源获取即初始化）的技术，对普遍的指针进行封装，这使得智能指针实质是一个对象，行为表现却像一个指针；
        - 智能指针的作用，是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来避免；
        - 智能指针还有一个作用，是把值语义转换成引用语义；
```
- 智能指针的分类：c++11新特性，需要包含头文件memory，有shared_ptr、unique_ptr和weak_ptr；
```
	- shared_ptr：
		a.特点：多个指针指向相同的对象；
       	b.shared_ptr内部使用引用计数，每一个shared_ptr的拷贝都指向相同的内存；
        	每使用一次，内部的引用计数加1，；每析构一次，内部的引用计数减1；
            当计数为0时，自动释放内存；后来指向的对象引用计数加1，指向后来的对象；
        c.拷贝和赋值：拷贝使得对象的引用计数加1，赋值使得原来对象的引用计数减1；
        d.可以使用get()函数获取原始指针；
        e.陷阱：避免循环引用：
        	shared_ptr的一个最大的陷阱就是循环引用；
            循环引用会导致堆内存无法正确释放，导致内存泄露（看weak_ptr）；
	- unique_ptr：
		a.特点：唯一的拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（禁止拷贝语义，只有移动语义来实现）；
        b.相比于原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放；
        c.unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域；
        	离开作用域时，若其指向对象，则将其所指向的对象销毁（默认使用delete操作符，用户可以指定其他操作）。
        d.unique_ptr指针与其所指对象的关系：
        	在智能指针生命周期内，可以改变智能指针所指对象，如：创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转义所有权；
	- weak_ptr：
		a.特点：是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为：
        	没有重载operator*和->；
        b.weak_ptr最大的作用在于：协助shared_ptr工作，像旁观者那样观测资源的使用情况；
        c.weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权（weak_ptr是shared_ptr的友元类（friend））；
        d.weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加；
        e.使用weak_ptr的成员函数：
        	use_count()可以观测资源的引用计数；
            expired()的功能等价于use_count()==0，但是更快，表示被观测的资源（即：shared_ptr管理的资源）已经不存在；
            lock()：weak_ptr重要的成员函数，它从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。
            	但当expired()==true时，lock()函数将返回一个存储空指针的shared_ptr；
```
- 循环引用问题：[案例](https://www.cnblogs.com/wxquare/p/4759020.html)
- 所有的智能指针都会重载->和*操作符；
#### 正则表达式库（了解）
#### 语言级线程支持
- 对标准库的扩充：
```
	- std::thread
	- std::mutex/std::unique_lock
	- std::future/std::packaged_task
	- std::condition_variable
```
#### 结构化绑定(c++17)
#### ...
## 多线程和线程池
### 进程和线程
- 进程是操作系统分配存储资源的最小单元；
- 线程是程序执行、cpu调度的最小单元；
- [进程和线程](https://www.cnblogs.com/tiankong101/p/4229584.html)
### 线程池原理
## I/O原理
### 多路I/O复用
#### select
#### epoll
## 数据库
### sql
#### mysql（数据结构和原理）
### nosql
#### redis（数据结构和原理）
## 网络编程
### tcp协议栈
#### 三次握手
#### 四次挥手
#### socket状态转换过程
#### 与I/O多路复用结合
## 开源库
- [开源库大全](https://blog.csdn.net/qing101hua/article/details/78614604)