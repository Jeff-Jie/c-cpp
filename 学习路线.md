[TOC]
<div style='display: none'> [TOC] 为目录</div>
- <注>：在恰当的场合使用恰当的特性

# c++服务器开发
## c++语言
### c++初级
#### 命名空间
#### 面向对象编程思想
#### 类的封装
#### 构造与析构
#### 静态成员
#### This指针
#### 友元函数与友元类
#### 运算符重载、函数重载
#### 继承与派生
#### 虚函数与多态
#### 函数模板与类模板
#### 输入输出流
#### 异常处理
### c++中/高级——c\+\+标准库
#### 标准c++ I/O类（了解）
- ios：抽象基类
- istream：通用输入流和其他输入流的基类
- ostream：通用输出流和其他输出流的基类
- iostream：通用输入输出流和其他输入输出流的基类
- ifstream：输入文件流类
- ofstream：输出文件流类
- fstream：输入输出文件流类
- istrstream：输入字符串流类
- ostrstream：输出字符串流类
- strstream：输入输出字符串流类
#### 字符串string类
- 数据结构
#### 数值类?
#### STL容器类（基本数据结构和原理）
- vector: 每个元素在内存上是连续的，支持高效遍历、尾端插入和删除；
```
（1）特点：
	- 动态数组，在堆中分配内存，即使大小减小，内存也不会释放；如果新值 > 当前大小，会再分配内存；
	- 内存的动态增长，首地址不变；
	- 地址连续的顺序序列；
	- 能够感知内存分配器的（Allocator-aware）：
		vector使用一个内存分配器对象来动态的处理存储需求；
```
- list: 元素地址不连续，具有双链表结构，支持高效的随机插入/删除；
```
（1）特点：
	- 线性双向链表结构，有若干节点，每个节点包括一个信息块、一个前驱指针和一个后继指针；
	- 不支持[]操作符和at()函数；
	- 相对于vector，占用更多内存；（因为每个节点至少包含2个指针）
```
- map: 关联容器，提供一对一的数据处理能力；
```
（1）特点：
	- map内部自建一颗红黑树（一种非严格意义上的平衡二叉树）
		这棵树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的；
    - 根据key值快速查找记录，查找的复杂度基本是log(n)，例如：
    	如果有1000个记录，最多查找10次；
        如果有1000000个记录，最多查找20次；
```
- 队列:
```
（1）queue： 是一个容器适配器类型
	- 特点：
		a.队列是一个容器适配器类型，被设计成用来运行FIFO（先进先出）场景；
	- 队列在多线程中的应用：
		a.生产——消费模型，实现解耦；
（2）dequeue: 每个元素在内存上是连续的，支持高效遍历、首/尾端插入和删除；
	- 双端队列的数据被表示为一个分段数组，容器中的元素分段存放在一个大小固定的数组中；
	- 容器需要维护一个存放这些数组首地址的索引数组；
	- 特点：
		a.首地址的索引数组地址连续，双端队列本质上每一段的地址不连续；
（3）priority_queue：优先队列
	- 具有队列的所有特性，包括基本操作，在这基础上，增加了一个内部的排序，本质是一个堆实现的（默认是大顶堆）
	- 特点：
		a.队列中的最大元素总是位于首部（出队时，是将当前队列中最大的元素出队）
        b.元素的比较规则默认按照元素值由大到小排序（可以重载'<'来重新定义比较规则）
    	c.在默认的优先队列中，优先级高的先出队（在默认的int型中，先出队的为最大的数）
```
#### STL算法库algorithm
#### STL函数对象（仿函数）
- 概念：
```
（1）函数对象：
	- 首先，是一个对象：即某个类的示例；
	- 其次，函数对象的行为和函数一致：即可以像调用函数一样来使用函数对象（参数传递、返回值等），这种方式是通过重载类的'()'操作符实现的；
（2）重载'()'操作符的类，它的对象叫做“函数对象”，即它是类似于函数的对象（可以像函数一样调用），称为“仿函数”；
	<注>：函数对象（仿函数）是一个类，不是一个函数；
（3）术语：
	- 一元仿函数：重载'()'操作符有一个参数；
	- 二元仿函数：重载'()'操作符有两个参数；
	- 一元谓词： 返回值是bool类型的函数对象或普通函数，有一个参数；
	- ...
（4）STL内建的函数对象 #include <functional>
	- 算数类函数对象：
	- 关系运算类：
	- 逻辑运算类：
	<注>：用这些类的对象当做函数使用时，用法与函数完全相同；
```
- 函数对象的作用和应用场景：
#### STL迭代器
- 迭代器（iterator）：是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器；
- 抽象思想的经典应用：迭代器作为容器(vector、list等)与STL算法的“粘黏剂”，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中；
- 实现：
```
（1）内部构成 ：
	- 提供一个遍历容器内部所有元素的接口，因此内部必须保存一个与容器相关联的指针；
	- 重载常用的运算符来方便遍历（其中最重要的是'*'、'->'和'++'）；
	- 
```
#### STL分配器（后续重点了解）
#### 本地化库
- [本地化库](https://zh.cppreference.com/w/cpp/locale)
#### 异常处理类
- [c++异常处理底层机制](https://blog.csdn.net/pzp201833/article/details/80996133)
- [c++异常处理基本思想](https://blog.csdn.net/zyq522376829/article/details/46775931)
#### 杂项支持库（非重点）
### c++精通（c\+\+11/14/17新特性）
#### nullptr
- c++空指针
- c的NULL与c++的nullptr：
```
（1）区别：
	- NULL在c++中，被明确定义为整数0；
	- NULL在c中，被定义成 ((void*)0)；（即：NULL实际上是一个void*指针）；
（2）特点：
	- nullptr用于标识空指针，是std::nullptr_t类型的(constexpr)变量；
	- nullptr可以转换成任何指针类型和bool类型；（主要为了兼容普通指针可以作为条件判断语句的写法）
	- nullptr不能被转换为整数；
```
#### constexpr（常量表达式）
- constexpr修饰的是编译时期的常量；
- const与constexpr的区别：
```
（1）const为运行时常量，constexpr为编译时常量（与#define作用相同）；
	const和constexpr修饰的都是read-only的值，但：
    	- constexpr在程序执行前已经得到了具体的值；
    	- const在程序执行过程中，得到的具体值；
```
- constexpr常量表达式的要求：
```
	并非所有的函数都有资格成为常量表达式函数，具体要求如下：
（1）函数体只有单一的return返回语句；
（2）函数必须有返回值（即，不能为void函数）；
（3）在使用前必须已有定义；
（4）return返回语句表达式中不能使用非常量表达式的函数、全局数据，并且必须是一个常量表达式；
```
- constexpr的优势：
```
（1）是一种很强的约束，更好的保证程序的正确语义不被破坏；
（2）编译器可以在编译时对constexpr的代码进行非常大的优化，比如：将用到constexpr表达式都直接替换成最终结果；
（3）相比宏定义来说，没有额外开销，但更安全可靠；
```
#### auto
- c++98 auto:（极少使用）
- c++11 auto:
```
（1）特点：
	- auto可以在声明变量的时候，根据变量初始值类型，自动推断匹配的类型；
		类似的关键字还有decltype；
        可以使用typeid(i).name()获得变量的类型；
    - auto的自动类型推断发生在编译时期，所以使用auto并不会造成程序运行时的效率问题；
（2）用途：
	- 用于代替冗长复杂、变量使用范围专一的变量声明；
	- 在定义模板函数时，用于声明以来模板参数的变量类型；
	- 用于模板函数依赖于模板参数的返回值
		<注>：第二点和第三点是因为模板参数的类型是可变的，无法在函数内部形成统一的变量类型；
（3）注意事项：
	- auto变量必须在定义时初始化，这点类似与const；
	- 定义在一个auto序列的变量，必须时钟推导成同一类型；
	- 如果初始化表达式是引用，则去除引用语义；
	- 如果初始化表达式为const或volatile（或者两者兼有），则去除const/volatile语义；
	- 如果auto关键字带上&号，则不去除const语义；
	- 初始化表达式为数组时，auto关键字推导类型为指针；
	- 若表达式为数组且auto带上&号，则推导类型为数组类型；
	- 函数参数或模板参数不能被声明为auto；（c++11错误，c++14可以使用auto参数）
```
#### decltype
- 与auto关键字一样，用于进行编译时类型推导，它与auto的区别是：
```
	- decltype的类型推导不像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型；
	- decltype不会对表达式进行求值；
```
- decltype使用方法：
```
	- 推导出表达式类型；
		int i = 4;
        decltype(i) a;	// 推导结果为int，声明a变量的类型为int；
	- 与using/typedef合用，用于定义类型；
		using size_t = decltype(sizeof(0));	// sizeof(a)的返回值为size类型
	- 重用匿名类型；
		struct {
        	int d;
            double b;
        }anon_s;
        decltype(anon_s) as;	// 定义了一个上面匿名的结构体；
	- 泛型编程中结合auto，用于追踪函数的返回值类型；（decltype的最大用途）
		template<typename _Tx, typename _Ty>
        auto multiply(_Tx x, _Ty y)->decltype(_Tx*_Ty) {
        	return x*y;
        }
```
- decltype推导的四条规则：
```
（1）如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型；
	此外，如果e是一个被重载的函数，则会导致编译错误；
（2）否则，假设e的类型是T，如果e是一个将亡值，那么decltype(e)为T&&；
（3）否则，假设e的类型是T，如果e是一个左值，那么decltype(e)为T&；
（4）否则，假设e的类型是T，则decltype(e)为T；
```
#### 区间迭代（范围for循环）
#### 初始化列表
#### 模板增强
#### 面向对象增强
#### Lambda表达式
#### 函数对象包装器
#### 右值引用(std::move)
#### 新增容器
- array:
- forward_list:
- unordered_map:
- unordered_set:
- unordered_multimap:
- unordered_multiset:
- tuple(元组):
#### 智能指针
#### 正则表达式库（了解）
#### 语言级线程支持
#### 结构化绑定
#### ...
## 多线程和线程池
### 进程和线程
### 线程池原理
## I/O原理
### 多路I/O复用
#### select
#### epoll
## 数据库
### sql
#### mysql（数据结构和原理）
### nosql
#### redis（数据结构和原理）
## 网络编程
### tcp协议栈
#### 三次握手
#### 四次挥手
#### socket状态转换过程
#### 与I/O多路复用结合
## 开源库
- [开源库大全](https://blog.csdn.net/qing101hua/article/details/78614604)