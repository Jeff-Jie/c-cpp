[TOC]
<div style='display: none'> [TOC] 为目录</div>
- <注>：在恰当的场合使用恰当的特性

# c++服务器开发
## c++语言
### c++初级
#### 命名空间
#### 面向对象编程思想
#### 类的封装
#### 构造与析构
#### 静态成员
#### This指针
#### 友元函数与友元类
#### 运算符重载、函数重载
#### 继承与派生
#### 虚函数与多态
#### 函数模板与类模板
#### 输入输出流
#### 异常处理
### c++中/高级——c\+\+标准库
#### 标准c++ I/O类（了解）
- ios：抽象基类
- istream：通用输入流和其他输入流的基类
- ostream：通用输出流和其他输出流的基类
- iostream：通用输入输出流和其他输入输出流的基类
- ifstream：输入文件流类
- ofstream：输出文件流类
- fstream：输入输出文件流类
- istrstream：输入字符串流类
- ostrstream：输出字符串流类
- strstream：输入输出字符串流类
#### 字符串string类
- 数据结构
#### 数值类?
#### STL容器类（基本数据结构和原理）
- vector: 每个元素在内存上是连续的，支持高效遍历、尾端插入和删除；
```
（1）特点：
	- 动态数组，在堆中分配内存，即使大小减小，内存也不会释放；如果新值 > 当前大小，会再分配内存；
	- 内存的动态增长，首地址不变；
	- 地址连续的顺序序列；
	- 能够感知内存分配器的（Allocator-aware）：
		vector使用一个内存分配器对象来动态的处理存储需求；
```
- list: 元素地址不连续，具有双链表结构，支持高效的随机插入/删除；
```
（1）特点：
	- 线性双向链表结构，有若干节点，每个节点包括一个信息块、一个前驱指针和一个后继指针；
	- 不支持[]操作符和at()函数；
	- 相对于vector，占用更多内存；（因为每个节点至少包含2个指针）
```
- map: 关联容器，提供一对一的数据处理能力；
```
（1）特点：
	- map内部自建一颗红黑树（一种非严格意义上的平衡二叉树）
		这棵树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的；
    - 根据key值快速查找记录，查找的复杂度基本是log(n)，例如：
    	如果有1000个记录，最多查找10次；
        如果有1000000个记录，最多查找20次；
```
- 队列:
```
（1）queue： 是一个容器适配器类型
	- 特点：
		a.队列是一个容器适配器类型，被设计成用来运行FIFO（先进先出）场景；
	- 队列在多线程中的应用：
		a.生产——消费模型，实现解耦；
（2）dequeue: 每个元素在内存上是连续的，支持高效遍历、首/尾端插入和删除；
	- 双端队列的数据被表示为一个分段数组，容器中的元素分段存放在一个大小固定的数组中；
	- 容器需要维护一个存放这些数组首地址的索引数组；
	- 特点：
		a.首地址的索引数组地址连续，双端队列本质上每一段的地址不连续；
（3）priority_queue：优先队列
	- 具有队列的所有特性，包括基本操作，在这基础上，增加了一个内部的排序，本质是一个堆实现的（默认是大顶堆）
	- 特点：
		a.队列中的最大元素总是位于首部（出队时，是将当前队列中最大的元素出队）
        b.元素的比较规则默认按照元素值由大到小排序（可以重载'<'来重新定义比较规则）
    	c.在默认的优先队列中，优先级高的先出队（在默认的int型中，先出队的为最大的数）
```
#### STL算法库algorithm
#### STL函数对象（仿函数）
- 概念：
```
（1）函数对象：
	- 首先，是一个对象：即某个类的示例；
	- 其次，函数对象的行为和函数一致：即可以像调用函数一样来使用函数对象（参数传递、返回值等），这种方式是通过重载类的'()'操作符实现的；
（2）重载'()'操作符的类，它的对象叫做“函数对象”，即它是类似于函数的对象（可以像函数一样调用），称为“仿函数”；
	<注>：函数对象（仿函数）是一个类，不是一个函数；
（3）术语：
	- 一元仿函数：重载'()'操作符有一个参数；
	- 二元仿函数：重载'()'操作符有两个参数；
	- 一元谓词： 返回值是bool类型的函数对象或普通函数，有一个参数；
	- ...
（4）STL内建的函数对象 #include <functional>
	- 算数类函数对象：
	- 关系运算类：
	- 逻辑运算类：
	<注>：用这些类的对象当做函数使用时，用法与函数完全相同；
```
- [std::bind和std::function](https://www.cnblogs.com/jiayayao/p/6139201.html)
- 函数对象的作用和应用场景：
#### STL迭代器
- 迭代器（iterator）：是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器；
- 抽象思想的经典应用：迭代器作为容器(vector、list等)与STL算法的“粘黏剂”，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中；
- 实现：
```
（1）内部构成 ：
	- 提供一个遍历容器内部所有元素的接口，因此内部必须保存一个与容器相关联的指针；
	- 重载常用的运算符来方便遍历（其中最重要的是'*'、'->'和'++'）；
	- 
```
#### STL分配器（后续重点了解）
#### 本地化库
- [本地化库](https://zh.cppreference.com/w/cpp/locale)
#### 异常处理类
- [c++异常处理底层机制](https://blog.csdn.net/pzp201833/article/details/80996133)
- [c++异常处理基本思想](https://blog.csdn.net/zyq522376829/article/details/46775931)
#### 杂项支持库（非重点）
### c++精通（c\+\+11/14/17新特性）
#### nullptr
- c++空指针
- c的NULL与c++的nullptr：
```
（1）区别：
	- NULL在c++中，被明确定义为整数0；
	- NULL在c中，被定义成 ((void*)0)；（即：NULL实际上是一个void*指针）；
（2）特点：
	- nullptr用于标识空指针，是std::nullptr_t类型的(constexpr)变量；
	- nullptr可以转换成任何指针类型和bool类型；（主要为了兼容普通指针可以作为条件判断语句的写法）
	- nullptr不能被转换为整数；
```
#### constexpr（常量表达式）
- constexpr修饰的是编译时期的常量；
- const与constexpr的区别：
```
（1）const为运行时常量，constexpr为编译时常量（与#define作用相同）；
	const和constexpr修饰的都是read-only的值，但：
    	- constexpr在程序执行前已经得到了具体的值；
    	- const在程序执行过程中，得到的具体值；
```
- constexpr常量表达式的要求：
```
	并非所有的函数都有资格成为常量表达式函数，具体要求如下：
（1）函数体只有单一的return返回语句；
（2）函数必须有返回值（即，不能为void函数）；
（3）在使用前必须已有定义；
（4）return返回语句表达式中不能使用非常量表达式的函数、全局数据，并且必须是一个常量表达式；
```
- constexpr的优势：
```
（1）是一种很强的约束，更好的保证程序的正确语义不被破坏；
（2）编译器可以在编译时对constexpr的代码进行非常大的优化，比如：将用到constexpr表达式都直接替换成最终结果；
（3）相比宏定义来说，没有额外开销，但更安全可靠；
```
#### auto
- c++98 auto:（极少使用）
- c++11 auto:
```
（1）特点：
	- auto可以在声明变量的时候，根据变量初始值类型，自动推断匹配的类型；
		类似的关键字还有decltype；
        可以使用typeid(i).name()获得变量的类型；
    - auto的自动类型推断发生在编译时期，所以使用auto并不会造成程序运行时的效率问题；
（2）用途：
	- 用于代替冗长复杂、变量使用范围专一的变量声明；
	- 在定义模板函数时，用于声明以来模板参数的变量类型；
	- 用于模板函数依赖于模板参数的返回值
		<注>：第二点和第三点是因为模板参数的类型是可变的，无法在函数内部形成统一的变量类型；
（3）注意事项：
	- auto变量必须在定义时初始化，这点类似与const；
	- 定义在一个auto序列的变量，必须始终推导成同一类型；
	- 如果初始化表达式是引用，则去除引用语义；
	- 如果初始化表达式为const或volatile（或者两者兼有），则去除const/volatile语义；
	- 如果auto关键字带上&号，则不去除const语义；
	- 初始化表达式为数组时，auto关键字推导类型为指针；
	- 若表达式为数组且auto带上&号，则推导类型为数组类型；
	- 函数参数或模板参数不能被声明为auto；（c++11错误，c++14可以使用auto参数）
```
#### decltype
- 与auto关键字一样，用于进行编译时类型推导，它与auto的区别是：
```
	- decltype的类型推导不像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型；
	- decltype不会对表达式进行求值；
```
- decltype使用方法：
```
	- 推导出表达式类型；
		int i = 4;
        decltype(i) a;	// 推导结果为int，声明a变量的类型为int；
	- 与using/typedef合用，用于定义类型；
		using size_t = decltype(sizeof(0));	// sizeof(a)的返回值为size类型
	- 重用匿名类型；
		struct {
        	int d;
            double b;
        }anon_s;
        decltype(anon_s) as;	// 定义了一个上面匿名的结构体；
	- 泛型编程中结合auto，用于追踪函数的返回值类型；（decltype的最大用途）
		template<typename _Tx, typename _Ty>
        auto multiply(_Tx x, _Ty y)->decltype(_Tx*_Ty) {
        	return x*y;
        }
```
- decltype推导的四条规则：
```
（1）如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型；
	此外，如果e是一个被重载的函数，则会导致编译错误；
（2）否则，假设e的类型是T，如果e是一个将亡值，那么decltype(e)为T&&；
（3）否则，假设e的类型是T，如果e是一个左值，那么decltype(e)为T&；
（4）否则，假设e的类型是T，则decltype(e)为T；
```
#### 区间迭代（范围for循环）
- string、array和所有的STL容器，都可以被新的区间迭代方式迭代；
- 如果想让自己的数据结构使用区间迭代语法，则需要：
```
	- 这个数据结构必须要有begin()和end()方法，成员方法和独立函数都可以，这两个方法分别返回开始和结束的迭代器；
	- 迭代器支持'*'操作符、'!='操作符、'++'方法（前缀形式、成员函数和独立函数都可）；
  实现这5个函数，就可以有一个支持区间迭代的数据结构。
  begin()和end()可以是非成员函数，甚至可以适配现有的数据结构，而不用实现STL风格的迭代器。
  因此，需要做的就是创建自己的支持*、前++和!=的嗲带起，并定义好自己的being()和end()；
```
- 区间迭代可以与STL中的for_each有着同样的性能；
#### 初始化列表
- [列表初始化](https://blog.csdn.net/hailong0715/article/details/54018002)
#### 模板增强
- 模板函数的默认模板参数；
- 外部模板：是c++11中一个关于模板性能上的改进；

#### 面向对象增强
#### Lambda表达式
- lambda表达式本质上就是重载了()运算符的类，称为“functor”，即行为像函数的类。因此，lambda表达式对象其实就是一个匿名的functor；
- 说明：
```
（1）构成：
	- 一个标准的lambda表达式包括：
		捕获列表：捕获外部变量列表；
        	值捕获、引用捕获和外部捕获；
        参数列表：形参列表；
        mutable指示符：用来说明是否可以修改捕获变量；
        exception：异常设定；
        尾置返回类型(->返回类型)：返回类型；
        函数体：函数体
        [capture list](params list) mutable exception->return type {function body};
    - 根据反汇编分析，lambda表达式中的代码是在一个单独的函数中执行的，这个函数在调用时创建了自己的栈帧，而捕获的变量在其他的栈帧中（虽然通过ebp可以进行栈帧回溯，但显然是一种不合理的做法）。
（2）注意：
	- 如果lambda表达式中忽略括号和形参列表，则相当于指定的函数没有入参；
	- lambda表达式中不能指定参数的默认值；
	- 如果忽略返回值类型，则由编译器做自动类型推断；
```
- 捕获列表：由于lambda表达式在某函数内定义的，因此会希望其能使用函数内部的局部变量，这时可以使用“捕获列表”
```
	- 值捕获：
		值捕获和参数传递中的值传递类似，被捕获的变量的值，在lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响lambda表达式中的值；
       	<注>：不能在lambda表达式中修改捕获变量的值；
    - 引用捕获：
    	使用引用捕获一个外部变量，需要在捕获列表变量前面加上一个引用说明符&；
    - 外部捕获（隐式捕获）：
    	我们可以让编译器根据函数体中的代码来推断需要捕获哪些变量；
        隐式捕获有两种方式：
        	[=]：表示以值捕获的方式捕获外部变量；
            [&]：表示以引用捕获的方式捕获外部变量；
```
#### 函数对象包装器
- 说明：
```
	c++11 std::function是一种通用、多态的函数封装，它的示例可以对任何可以调用的目标实体进行存储、复制和调用；
    它也是对c++中现有的可调用实体的一种类型安全的包装（相对来说，函数指针的调用不是类型安全的）；
    std::function是函数的容器，可以更加方便的将函数、函数指针作为对象进行处理；
```
#### 右值引用(std::move)
- [右值引用](https://www.cnblogs.com/likaiming/p/9045642.html)
- 左值和右值的区分标准：能否获取地址：
```
	- 左值：可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值；
		但是修饰符const的出现，使得可以声明如下标识符，它可以获取地址，但是没办法对其赋值：
        	const int& i = 10;
	- 右值表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等；无法获取地址，但不代表其不可改变，当定义了右值的右值引用时，就可以改变右值；
```
- c++11增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置：
```
	即： 右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置：（临时变量会引用关联到右值时，右值被存储到特定位置）
    	int && iii = 10;
```
- 右值引用和移动语义：
```
（1）说明：
	- 在旧的c++中，出现了很多不必要的拷贝，因为在某些情况下，对象拷贝完成后就销毁了；
	- c++11新标准，引入了移动操作，减少了很多复制操作，而右值引用正式为了支持移动操作为引入的新的引用类型；
（2）std::move()函数：
	- 根据右值引用的语法规则，不能将右值引用绑定到一个左值上，c++11引入右值引用，并且提供了std::move()函数，用来获得绑定到左值上的右值引用（即：为右值引用绑定到左值提供了可能）
	- 该函数需要：#include <utility>
		int &&iii = std::move(ii);
```
#### 新增容器
- array:
- forward_list:
- unordered_map:
- unordered_set:
- unordered_multimap:
- unordered_multiset:
- tuple(元组):
#### 智能指针
- 理解智能指针：
```
	作用：方便管理堆内存；
    三个层次：
    	- 较浅层面：
    		智能指针利用一种叫“RAII”（资源获取即初始化）的技术，对普遍的指针进行封装，这使得智能指针实质是一个对象，行为表现却像一个指针；
        - 智能指针的作用，是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来避免；
        - 智能指针还有一个作用，是把值语义转换成引用语义；
```
- 智能指针的分类：c++11新特性，需要包含头文件memory，有shared_ptr、unique_ptr和weak_ptr；
```
	- shared_ptr：
		a.特点：多个指针指向相同的对象；
       	b.shared_ptr内部使用引用计数，每一个shared_ptr的拷贝都指向相同的内存；
        	每使用一次，内部的引用计数加1，；每析构一次，内部的引用计数减1；
            当计数为0时，自动释放内存；后来指向的对象引用计数加1，指向后来的对象；
        c.拷贝和赋值：拷贝使得对象的引用计数加1，赋值使得原来对象的引用计数减1；
        d.可以使用get()函数获取原始指针；
        e.陷阱：避免循环引用：
        	shared_ptr的一个最大的陷阱就是循环引用；
            循环引用会导致堆内存无法正确释放，导致内存泄露（看weak_ptr）；
	- unique_ptr：
		a.特点：唯一的拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（禁止拷贝语义，只有移动语义来实现）；
        b.相比于原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放；
        c.unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域；
        	离开作用域时，若其指向对象，则将其所指向的对象销毁（默认使用delete操作符，用户可以指定其他操作）。
        d.unique_ptr指针与其所指对象的关系：
        	在智能指针生命周期内，可以改变智能指针所指对象，如：创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转义所有权；
	- weak_ptr：
		a.特点：是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为：
        	没有重载operator*和->；
        b.weak_ptr最大的作用在于：协助shared_ptr工作，像旁观者那样观测资源的使用情况；
        c.weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权（weak_ptr是shared_ptr的友元类（friend））；
        d.weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加；
        e.使用weak_ptr的成员函数：
        	use_count()可以观测资源的引用计数；
            expired()的功能等价于use_count()==0，但是更快，表示被观测的资源（即：shared_ptr管理的资源）已经不存在；
            lock()：weak_ptr重要的成员函数，它从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。
            	但当expired()==true时，lock()函数将返回一个存储空指针的shared_ptr；
```
- 循环引用问题：[案例](https://www.cnblogs.com/wxquare/p/4759020.html)
- 所有的智能指针都会重载->和*操作符；
#### 正则表达式库（了解）
#### 语言级线程支持
- 对标准库的扩充：
```
	- std::thread
	- std::mutex/std::unique_lock
	- std::future/std::packaged_task
	- std::condition_variable
```
#### 结构化绑定(c++17)
#### ...
## 多线程和线程池
### 进程和线程
- 进程是操作系统分配存储资源的最小单元；
- 线程是程序执行、cpu调度的最小单元；
- [进程和线程](https://www.cnblogs.com/tiankong101/p/4229584.html)
### 线程池原理：
- [线程池原理](https://www.cnblogs.com/ailumiyana/p/10016965.html)
## I/O原理
### 多路I/O复用
#### 同步和异步、阻塞和非阻塞
- 同步和异步： 描述的是”用户线程“和”内核“的交互方式；
```
	同步：指用户线程发起I/O请求后，需要”等待“或”轮询“内核I/O操作完成后才能继续执行；
    异步：指用户线程发起I/O请求后，仍可继续执行，当内核I/O操作完成后会通知用户线程，或调用用户线程注册的回调函数；
```
- 阻塞和非阻塞： 描述的是”用户线程“调用”内核I/O“操作的方式
```
	阻塞：指I/O操作需要彻底完成后才能返回到用户空间；
    非阻塞：指I/O操作被调用后立即返回给用户一个状态值，无需等待I/O操作彻底完成；
```
#### 基础——常见的I/O模型
- 同步阻塞I/O： 传统I/O模型；
```
（1）特点：
	- 用户线程在内核进行I/O操作时被阻塞；
	- 属于请求应答式
（2）缺点：
	- 用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据；
	- 整个I/O请求过程中，用户线程是被阻塞的，这导致用户在发起I/O请求时，不能做任何事情，对cpu的资源利用率不够；
```
- 同步非阻塞I/O： 默认创建的socket都是阻塞的，非阻塞I/O要求socket被设置成NONBLOCK；
```
（1）特点：
	- 是在同步阻塞I/O基础上，将socket设置为NONBLOCK，这样用户线程可以在发起I/O请求后立即返回；
	- 用户线程发起I/O请求时立即返回，但并未读取到任何数据，用户线程需要不断的发起I/O请求，直到数据到达后，才能真正读取到数据，继续执行；
（2）缺点：
	- 用户需要不断的调用read，尝试读取socket中的数据；
	- 整个I/O请求的过程中，虽然用户线程每次发起I/O请求后可以立即返回，但是为了等到数据，仍需要不断的轮询、重复请求，消耗了大量的cpu资源；
（3）一般很少直接使用这种模型，而是在其他I/O模型中使用非阻塞I/O这一特性；
```
- I/O多路复用：经典的Reactor设计模式，也被称作“异步阻塞I/O”，代表为linux的epoll；
```
（1）特点：
	- I/O多路复用是建立在内核提供的多路分离函数select()基础之上；
	- 使用select()函数可以避免同步非阻塞I/O模型中轮询等待的问题；
	- select函数与同步阻塞模型没有太大区别，甚至添加了监视socket，以及调用select()函数的额外操作，效率更差；
		但是，使用select()以后最大的优势，就是用户可以在一个线程内同时处理多个socket的I/O请求；
        用户可以注册多个socket，然后不断的调用select()读取被激活的socket，即：
        	可以达到在同一个线程内同时处理多个I/O请求的目的；
        而在同步阻塞模型中，必须通过多线程方式才能达到这个目的；
（2）缺点：
	- 虽然上述方式允许单线程内处理多个I/O请求，但是每个I/O请求过程还是阻塞的（在select()函数上阻塞），平均时间甚至比同步阻塞I/O模型还要长；
（3）如果用户线程只注册自己感兴趣的socket或I/O请求，然后去做自己的事，等到数据到来时再进行处理，则可以提高CPU的利用率；
	I/O多路复用模型使用了Reactor设计模式实现了这一机制；
（4）Reactor设计模式：
    	通过Reactor的方式，可以将用户线程轮询I/O操作状态的工作统一交给handle_events事件循环进行处理；
        用户线程注册事件处理器之后，可以继续执行其他的工作（异步过程），而Reactor线程负责调用内核的select()函数检查socket状态，当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理等工作；
（5）由于select()函数是阻塞的，因此多路I/O复用也被称为”异步阻塞I/O模型“；（这里的阻塞，指的是select()函数执行时线程被阻塞，而不是指socket）
（6）I/O多路复用是最常使用的I/O模型，但是其异步程度还不够”彻底“，因为它使用会阻塞线程的select()系统调用，因此I/O多路复用只是异步阻塞I/O，而不是真正的异步I/O；
```
- 异步I/O： 经典的Proactor设计模式，也被称作”异步非阻塞I/O“；
```
	真正的异步I/O需要操作系统更强的支持；
（1）特点：
	- 在I/O多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取、处理数据；
		而在异步I/O模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在I/O完成后通知用户线程直接使用即可；
    异步I/O模型使用了Proactor设计模式实现了这一机制；
(2）Proactor与Reactor的区别：
	- Proactor和Reactor在结构上比较相似，不过在用户使用方式上差别较大；
	- Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数；
	- Proactor模式中，用户线程间asyncchronousOperation(读/写等)、Proactor以及操作完成时的CompletionHandler注册到asyncchronousOperationProcessor；
		asyncchronousOperationProcessor使用Facade模式，提供了一组异步操作API(读/写等)供用户使用；
        当用户线程调用异步API后，便继续执行自己的任务；asyncchronousOperationProcessor会开启独立的内核线程执行异步操作，实现真正的异步；
        当异步I/O操作完成时，asyncchronousOperationProcessor将用户线程与asyncchronousOperation一起注册的Proactor和CompletionHandler取出，然后将ComletionHandler与I/O操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作事件完成处理函数handle_event；
    - 虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是在一般系统中，Proactor实现为Singleton模式，以便于集中化分发操作完成事件；
（3）相比I/O多路复用模型，异步I/O并不很常用，不少高性能并发服务程序使用”I/O多路复用买模型+多线程任务处理“的架构基本可以满足需求；
	并且，目前操作系统对异步I/O的支持并非特别完善，更多的采用I/O多路复用模型”模拟“（例如：boost::asio）异步I/O的方式（I/O事件触发时，不直接通知用户线程，而是将数据读写完毕后，放到用户指定的缓冲区中；）
```
#### select和epoll
- I/O多路复用：
```
	I/O多路复用（又被称为“事件驱动”）：
    	操作系统提供了一个功能，当某个socket可读或可写的时候，会发出一个通知。这样当配合非阻塞的socket使用时，只有当系统通知了哪个描述符fd可读了，才执行read操作，可以保证每次read都能读到有效的数据，而不做仅仅返回-1和errno的无用功；
    写操作类似，操作系统通过select/poll/epoll等系统调用来实现，这些函数都可以同时监控多个描述符fd的读写就绪状态；
    这样，多个描述符fd的I/O操作都能在一个线程内并发交替的完成，即：I/O多路复用；
    这里的“复用”指的是复用同一个线程。
```
- select：
[select模型的原理、优点和缺点](https://www.cnblogs.com/-zyj/p/5719923.html)
```
（1）特点：
	select系统调用的目的是：在一段指定时间内，监听用户感兴趣的描述符fd上可读、可写和异常事件；
    poll和select，都可以阻塞式的、同时探测一组支持非阻塞的IO设备，直到某一个设备触发了事件或超过了指定的等待事件————即：他们的职责不是做I/O，而二十帮助调用者找到当前就绪的设备；
（2）select优点：
	- select是windows socket中最常见的模型，可以等待多个套接字；
（3）select缺点：
	- 每次调用select，都需要把fd集合，从用户态拷贝到内核态，在拷贝大量fd时开销很大；
	- 同时每次调用select，都需要在内核遍历传递进来的所有fd，在遍历大量fd时开销很大；
	- select支持的文件描述符数量小，默认只有1024；
```
- epoll：
[epoll内核原理极简图文解读](https://blog.csdn.net/linkedin_38454662/article/details/73337208)
[epoll基本原理及使用框架(含代码)](https://www.cnblogs.com/panfeng412/articles/2229095.html)
```
（1）特点：
	epoll是linux下I/O多路复用接口select/poll的增强版本，它能显著减少程序在大量并发连接中，只有少量胡偶尔的情况下，系统CPU的利用率，原因如下：
    	a. 它不会复用文件描述符fd集合来传递结果，而迫使开发者每次等待事件之前都必须重新准备要监听的文件描述符fd集合；
        b. 在获取事件时，它无须遍历整个被监听的描述符fd集合，而是只要遍历那些被内核I/O事件异步唤醒而加入Ready队列的描述符fd集合就行；
    epoll除了提供select/poll的I/O事件的Level Triggered(电平触发)外，还提供了Edge Triggered(边沿触发)，这就使得用户空间程序有可能缓存I/O状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率；
（2）epoll优点：
	- 支持一个进程打开大量的socket描述符；
	- I/O效率不随fd数目增加而线性下降；
	- 内核微调；
（3）工作模式：epoll有2中工作方式：LT和ET；
	- LT（默认工作方式）：
		同时致辞block和non-block socket，	
	- ET（高速工作方式）：
（4）epoll接口：
	epoll的接口非常简单，共有三个函数：
    	- int epoll_create(int size);
    		创建一个epoll句柄，会占用一个fd值，linux下查看/proc/进程id/fd/，是能够看到对应的fd的；
            return: int epfd;
           	所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽；
    	- int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    		epoll的事件注册函数，它不同于select()：
            	select是在监听事件时告诉内核要监听什么类型的事件；
                epoll是先注册要监听的事件类型；
    	- int epoll_wait(int epfd, struct epoll_event *event, int maxevents, int timeout);
    		等待事件的产生，类似于select()调用；
（5）epoll框架的使用方式：
	前提：包含头文件 #include <sys/epoll.h>
    a. 通过epoll_create(int maxfds)来创建一个epoll句柄，maxfds为epoll锁支持的最大句柄数；
    	这个函数会返回一个新的epoll句柄，之后的所有操作都将通过这个句柄来进行；
        在用完之后，需要调用close()来关闭这个epoll句柄；
    b. 在用户程序的网络主循环中，每一帧的调用epoll_wait()来查询所有的网络接口，看哪一个可读，哪一个可写；
    	基本的语法为：nfds = epoll_wait(kdpfd, events, maxevents, -1)
       	其中：
        	- kdpfd： 用epoll_create()创建后的句柄；
        	- events： 是一个epoll_event*的指针，当epoll_wait()函数操作成功后，events里面将存储所有的读写事件；
        	- max_events是当前需要监听的所有socket句柄数；
        	- 最后一个timeout是epoll_wait的超时，为0时马上返回，这里-1表示一直等待，直到有事件返回；
        	一般情况下，如果网络主循环是单独的线程，可以用-1来等待，这样可以保证效率；
            如果主逻辑与网络主循环是同一个线程的话，则可以用0来保证主循环的效率；
    c. epoll_wait()返回之后应该是一个循环，遍历所有的事件；
```
## 数据库
- [sql和nosql的区别](https://blog.csdn.net/han_cui/article/details/60765969)
### sql
#### mysql（数据结构和原理）
### nosql
#### redis（数据结构和原理）
## 网络编程
### tcp协议栈
#### 三次握手
#### 四次挥手
#### socket状态转换过程
#### 与I/O多路复用结合
## 开源库
- [开源库大全](https://blog.csdn.net/qing101hua/article/details/78614604)
## 常用设计模式
### 创建型模式（重点）
#### Factory工厂模式
#### Singleton单例模式
### 结构型模式
#### Bridge桥接模式
#### Adapter适配器模式（重点）
#### Decorator装饰器模式
#### Composite组合模式
#### Proxy代理模式
### 行为模式
#### Template模板模式
#### Strategy策略模式
#### Observer观察者模式（重点）
#### Visitor访问者模式
#### Chain of Responsibility职责链模式（重点）
#### Iterator迭代器模式（重点）
#### Interpreter解释器模式